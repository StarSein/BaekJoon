import java.util.*;

/*
1. 1번 노드와 2번 노드는 어떻게 배치해도 |d-b| 값이 0 이다
2. N개의 노드가 있다고 하면, 나머지 (N-2)개의 노드를 어떻게 배치할 것인가에 관한 문제다
3. 우선 나머지 노드의 개수를 M = N-2 라고 할 때,
    M이 짝수인 경우, 
        1번 노드의 자식 노드로 (M/2)개, 2번 노드를 루트로 하는 경사 트리의 노드로 (M/2)개
    M이 홀수인 경우,
        1번 노드의 자식 노드와 2번 노드를 루트로 하는 경사 트리의 노드로 배분하는데
        (M/2)개를 줄 곳과 (M/2 + 1)개를 줄 곳을 둘 중 어느 곳으로 선택하든 같다
    위와 같이 배치하는 방식이 최적인 것으로 관찰된다

   * 1번 노드부터 번호가 증가하는 순서대로 배치 위치를 결정한다고 가정하자
   1) 개수의 문제
    M개 중 1번 노드의 자식 노드에 p개, 2번 노드를 루트로 하는 경사 트리의 노드로 q개 배치한다고 하면
    1번 노드의 자식 노드 하나의 |d-b| 값은 q이고, 2번 노드를 루트로 하는 경사 트리의 노드 하나의 |d-b| 값은 p이다
    즉 |d-b| 값의 총합은 (2*p*q) 으로 p와 q의 차가 적을수록 이 값이 최대가 됨은 자명하다
    <- p=m-x, q=m+x 라고 할 때 (m-x)*(m+x)=m^2-x^2 의 값은 x가 최소일 때 최대이므로
   2) 장소의 문제
    이렇게 배치할 경우 M개의 노드가 거의 균등하게 |d-b| 값을 가질 수 있는데
    어느 한 개의 노드가 '두 곳'이 아닌 다른 곳에 배치될 경우
    해당 노드의 형제 노드 및 그 조상 노드는 |d-b| 값에 아무런 이득을 보지 못하며
    해당 노드 또한 '두 곳'에 배치할 때보다 더 이득을 취할 수는 없다
    따라서 '두 곳'이 아닌 곳에 배치해서 |d-b| 값의 총합이 더 증가할 수는 없다
 */

public class Main {

    public static void main(String[] args) throws Exception {
        // 입력을 받는다
        int N = new Scanner(System.in).nextInt();
        // |d-b| 총합의 최댓값을 정답 문자열에 추가한다
        StringBuilder sb = new StringBuilder();
        long answer = (N % 2 == 0
                ? (long) 2 * ((N - 2) / 2) * ((N - 2) / 2)
                : (long) 2 * ((N - 2) / 2) * ((N - 1) / 2));
        sb.append(answer).append('\n');

        // 최적의 트리를 구성하는 간선 정보를 정답 문자열에 추가한다
        sb.append("1 2\n");
        int mid = 3 + ((N - 2) / 2);
        for (int i = 3; i < mid; i++) {
            sb.append((i - 1) + " " + i + "\n");
        }
        for (int i = mid; i <= N; i++) {
            sb.append("1 " + i + "\n");
        }

        // 정답 문자열을 출력한다
        System.out.print(sb);
    }
}
